# NotifierBot项目计划书

## 阶段一：需求分析

### 1.1 项目背景与目标
- **项目名称**: 消息通知器
- **项目背景**: 在编写日报程序和订阅网站文章机器人时，同时遇到了需要将消息发送至某个客户端以实现通知提醒的功能，进而产生了该项目
- **业务目标**: 外部传递消息至本系统，转发至第三方
- **成功标准**: 成功对接日报程序和订阅网站文章机器人

### 1.2 功能需求分析
#### 核心功能
| 功能模块 | 优先级 | 功能描述 |
|---------|--------|----------|
| 通知模块 | 高 | 无状态，传递参数进行第三方通知 |

#### 扩展功能
| 功能模块 | 优先级 | 功能描述 |
|---------|--------|----------|
| 业务功能 | 中 | 针对日报程序和订阅文章管理，开发一些便携的api，例如指定次数和时间间隔发送相同的文本消息 |
| 网络对接 | 中 | http、rpc、mcp server |
| 权限验证 | 低 | 应用系统级别权限校验，例如使用satoken在网络接入层面进行拦截，该功能需要可以通过配置一键关闭和启用 |



### 1.3 风险分析

| 风险类型 | 风险描述 | 影响程度 | 发生概率 | 应对策略 |
|---------|----------|----------|----------|----------|
| 业务风险 | 通知器校验参数泄露；当流量可能被捕获时会发生。 | 中 | 中 | 使用池化技术一次注册，后续不再通过索引进行调用 |
| 资源风险 | 上下文资源损耗 | 高 | 高 | 使用池化技术进行复用和及时销毁 |
| 技术风险 | 高频调用同一通知器：由于服务商限制，通常第三方通知api会有qps限制以及程序实例的并发调用也会有问题，因此这里使用单实例，并尽可能降低qps。 | 高 | 高       | 1，通过mq进行流量削峰，适应程序的消费能力2.聚合部分允许合并的消息进行统一发送3，水平扩展下的qps问题：redis+lua进行令牌通算法 |



---

## 阶段二：系统设计

### 2.1 系统架构设计
#### 架构模式选择
- **架构类型**:  微服务架构

- **选择理由**: 该项目的开发意图是完成单一功能，而非一个完整的系统

- **架构图**:

  ![](https://cdn.wenzhuo4657.org/img/2025/11/a71e32bc1f6119b74dc48d9084175bb7.png)

#### 技术栈决策
| 层级 | 技术选择       | 版本 |
|------|------------|------|
| 后端 | springboot | [版本] |
| 缓存 | redis/Valkey     | [版本] |
| 消息队列 | rocketmq   |  |
| 部署 | docker/jar | [版本] |

### 2.2 模块设计
#### 系统模块划分
```
[项目名称]
├── Notifier(Notifier Module)
│   ├── 通知第三方
│   ├── 注册和销毁通知器实例
│   ├── 检查通知器是否可用：通过redis+lua检查qps等状态
├── Business(Business Module)
│   ├── 分流mq和直接通知： 根据通知器状态
│   ├── 业务逻辑处理： 例如需要连续发送3次消息
│   ├── 等等
├── Consumer(Consumer Module)
│   ├── 聚合消息： 设计聚合键（通知器类型+通知器Id）过滤需要聚合消息，


```

#### 模块间依赖关系
![](https://cdn.wenzhuo4657.org/img/2025/11/5167f815a31774fa7bc98fc89e268283.png)




### 2.3 API设计
#### RESTful API 规范
- **基础URL**: [https://api.example.com/v1]
- **认证方式**: [JWT/OAuth2/API Key等]
- **数据格式**: [JSON/XML]

#### API端点设计
| 端点 | 方法 | 描述 | 请求参数 | 响应格式 |
|------|------|------|----------|----------|
| /users | POST | 创建用户 | [用户信息] | [用户对象] |
| /users/{id} | GET | 获取用户信息 | [用户ID] | [用户对象] |
| /users/{id} | PUT | 更新用户信息 | [用户ID, 更新信息] | [更新后的用户对象] |



---

## 阶段三：开发计划

### 
### 3.1 迭代开发计划
#### 第一阶段：通知器核心模块开发（预计11.18-12.05）
- [x] 项目初始化和环境配置

- [ ] 通知器领域

  - [ ] 零散

    - [ ] qps和通知起状态的区分 ：两者的界限如何划分？

  - [ ] 接入第三方

    - [ ]  tgBot:  tgbot需要提前缓存chatID才能够主动通信。核心问题在于如果注册时获取chatId?
    - [ ] 微信： 暂时放弃。 原因： 微信没有官方的个人号sdk，只有微信公众号sdk，暂时不去实现。

  - [ ] 缓存

    - [x]  动态切换： 暂未接入nacos，在代码中提供入口切换

    - [x] 中间层隔离api： 提供入口获取策略和切换实现

    - [x] lua脚本增强：

      lua脚本原子性：  加载lua脚本至redis内存  -》 锁定服务器，其他客户端无法执行命令 -》 执行lua  -》 释放服务器

      ps： 集群环境下，lua脚本和事务的执行都被要求在一个节点当中，访问其他节点会报错

      ps： 使用EVALSHA介绍lua脚本发送的网络传输损耗

      （1） 通知器qps扣减，

      流程：  qps<10  》0  -> qps++ 

      必要性证明： 必须进行逻辑判断才能执行qps++

      （2）通知器状态判断，

      流程： qps<0 ? true:false

      无需lua，快速取回数值进行演示，没有逻辑操作的连续性

      - [ ] 序列化问题

         在实际执行lua脚本中，java中的数据和redis中读到的数据存在序列化的差异，针对场景，本次问题出现在argv上，对keys不会进行序列化，java数据序列化后是什么，argv就收到什么数据。











